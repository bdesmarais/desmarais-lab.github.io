# find previous events in the same cascade
previous.events <- node[which( (eha_data[,time] < time_i) & ( eha_data[,cascade] == cascade_i) & (eha_data[,event]==1)  )  ]
# calculate time since previous events
times.since.events <- time_i-eha_data[which( (eha_data[,time] < time_i) & ( eha_data[,cascade] == cascade_i) & (eha_data[,event]==1)  ),time  ]
if(length(previous.events) > 0){
col.ids <- paste(previous.events,node_i,sep="_")
diff_var_mat[i,col.ids] <- times.since.events
}
}
gt0 <- function(x){
sum(x>0)
}
GTOs <- apply(diff_var_mat,2,gt0)
diff_var_mat <- diff_var_mat[,which(GTOs >threshold)]
data.frame(eha_data,diff_var_mat,stringsAsFactors=F)
}
### DNEHM simulation
# nsim: the number of cascades to simulate
# x: [(number of nodes)x(number of observed time points)]x[number of covariates + 2]
## data frame of covariates to be used in simulating cascades. Note, each node
## must be at risk for the event until the maximum time.
# node: a character string name of the variable that gives the node id
# time: a character string name that gives the time, in integers
# beta: (ncol(x)-2)x1 matrix of regression coefficients with row names that match
## column names in x
# gamma: (number of diffusion ties)x1 matrix with row names of the form
## "sending-node]_receiving-node" such that sending and receiving node ids
## match elements of x[,node]. Elements should be non-negatave numeric values.
# a: a non-negative numeric value that models the exponential decay of sender influence
# note1: this function does not currently permit dyadic covariates
simulate_dnehm_discrete <- function(x,node,time,beta,gamma,a=0){
times <- sort(unique(x[,time]))
nodes <- sort(unique(x[,node]))
x_linear_predictor <- as.matrix(x[,row.names(beta)])%*%beta
event_times <- rep(NA,length(nodes))
source <- do.call('rbind',strsplit(rownames(gamma),"_"))[,1]
follower <- do.call('rbind',strsplit(rownames(gamma),"_"))[,2]
event <- rep(NA,nrow(x))
for(t in times){
nodes_at_risk <- nodes[is.na(event_times)]
for(n in nodes_at_risk){
xlp_nt <- x_linear_predictor[which((x[,time]==t) & (x[,node]==n))]
n_sources <- source[which(follower==n)]
source_effects <- gamma[which(follower==n),1]
source_times <- event_times[match(n_sources,nodes)]
# a = .25
# plot(0:20,exp(a*-(0:20)),ylim=c(0,1))
time_effects <- source_effects*exp(-a*(t-source_times))
time_effects <- time_effects[which(!is.na(time_effects))]
linear_predictor <- xlp_nt
if(length(time_effects)>0){
linear_predictor <- linear_predictor + sum(time_effects)
}
pr_nt <- 1/(1+exp(-linear_predictor))
event_nt <- 1*(pr_nt > runif(1))
event[which((x[,time]==t) & (x[,node]==n))] <- 0
if(event_nt==1){
event_times[which(nodes==n)] <- t
event[which((x[,time]==t) & (x[,node]==n))] <- 1
}
}
}
x <- data.frame(x,event,stringsAsFactors=F)
data.frame(na.omit(x),stringsAsFactors=F)
}
# function to estimate DNEHM
# eha_data: dataframe that includes one observation for each node
## at risk of experiencing the event during each at-risk time point
## in each cascade. Note, it is assumed that each node can experience
## an event in each cascade once, at most.
# node: a character string name of the variable that gives the node id
# time: a character string name that gives the time, in integers
# event: a binary 0/1 indicator of event occurrence
# cascade: a character string name of the variable that gives the cascade id
# threshold: if i does not experience an event prior to j in more than threshold
## cascades, the i/j column of the diffusion effects matrix is removed
# covariates: character vector of covariate names to include in the dnehm,
## excluding intercept.
dnehm <- function(eha_data,node,time,event,cascade,covariates,threshold=0,a=0){
require(glmnet)
require(msaenet)
data_for_dnehm <- data_dnehm_discrete(eha_data,node=node,time=time,event=event,cascade=cascade,threshold=threshold)
diffusion_effects_variables <- data_for_dnehm[,(ncol(eha_data)+1):ncol(data_for_dnehm)]
diffusion_effects_variables <- (diffusion_effects_variables>0)*exp(-a*(diffusion_effects_variables))
covariate_variables <- cbind(eha_data[,covariates])
x_for_glmnet <- cbind(as.matrix(covariate_variables),as.matrix(diffusion_effects_variables))
colnames(x_for_glmnet) <- c(covariates,colnames(diffusion_effects_variables))
y_for_glmnet <- eha_data[,event]
penalty.factors <- c(rep(0,ncol(covariate_variables)),rep(1,ncol(diffusion_effects_variables)))
lower.vals <- c(rep(-Inf,ncol(covariate_variables)),rep(0,ncol(diffusion_effects_variables)))
dnehm_estimate <- cv.glmnet(x_for_glmnet,y_for_glmnet,family="binomial",penalty.factor=penalty.factors,lower.limits=lower.vals,nfolds=10,alpha=1)
#dnehm_estimate <- glm(y_for_glmnet ~ x_for_glmnet,family="binomial",x=T)
dnehm_estimate
}
#*** Begin simulation example ***#
# basic data parameters
cascades <- 200
nodes <- 20
times <- 30
nties <- 50
# generate dataframe
time <- sort(rep(1:times,nodes))
node <- as.character(rep(1:nodes,times))
intercept <- rep(1,length(time))
covariate <- runif(length(time))-2
data_for_sim <- data.frame(time,node,intercept,covariate,stringsAsFactors=F)
# regression parameters
beta <- cbind(c(-2,.25))
rownames(beta) <- c("intercept","covariate")
## generate network effects
possible_ties <- rbind(t(combn(1:nodes,2)),t(combn(1:nodes,2))[,c(2,1)])
possible_ties <- paste(possible_ties[,1],possible_ties[,2],sep="_")
ties <- sample(possible_ties,nties)
gamma <- cbind(exp(rnorm(nties)/2))
rownames(gamma) <- ties
# initiate simulated data object
simulated_data <- NULL
# generate the data one cascade at a time (embarassingly parallel over c)
for(c in 1:cascades){
simulated_cascade <- simulate_dnehm_discrete(x=data_for_sim,node="node",time="time",beta=beta,gamma=gamma,a=0)
simulated_cascade <- data.frame(simulated_cascade,cascade=c,stringsAsFactors=F)
simulated_data <- rbind(simulated_data,simulated_cascade)
}
# Cascade-wise bootstrap to trim false positives (bolasso)
# https://www.di.ens.fr/willow/pdfs/icml_bolasso.pdf.
# the code below currently runs this as a cascade-wide bootstrap,
# but probably could do it with iid.
boot.nonzero.est <- NULL
nboot <- 10
unique.cascades <- 1:cascades
for(b in 1:nboot){
boot.samp <- sample(1:cascades,cascades,rep=T)
boot.data <- list()
for(i in 1:length(boot.samp)){
boot.data[[i]] <- simulated_data[simulated_data$cascade==boot.samp[i],]
}
boot.data <- data.frame(do.call('rbind',boot.data))
boot.dnehm_estimate <- dnehm(boot.data,node="node",time="time",event="event",covariates="covariate",cascade="cascade")
boot.dnehm.coef <- boot.dnehm_estimate$glmnet.fit$beta[,which(boot.dnehm_estimate$lambda==boot.dnehm_estimate$lambda.min)][which(boot.dnehm_estimate$glmnet.fit$beta[,which(boot.dnehm_estimate$lambda==boot.dnehm_estimate$lambda.min)] != 0)]
boot.recovered_edges <- substr(names(boot.dnehm.coef)[-c(1:(length(beta)-1))],2,nchar(names(boot.dnehm.coef)[-c(1:(length(beta)-1))]))
boot.nonzero.est <- c(boot.nonzero.est,boot.recovered_edges)
print(b)
}
freq.boot.est <- table(boot.nonzero.est)
true.est <- names(freq.boot.est)[which(freq.boot.est == nboot)]
recall <- mean(is.element(ties,true.est))
precision <- mean(is.element(true.est,ties))
recall
precision
# Cascade-wise bootstrap to trim false positives (bolasso)
# https://www.di.ens.fr/willow/pdfs/icml_bolasso.pdf.
# the code below currently runs this as a cascade-wide bootstrap,
# but probably could do it with iid.
bolasso.dnehm <- function(eha_data,node,time,event,cascade,covariates,threshold=0,a=0){
data_for_dnehm <- data_dnehm_discrete(eha_data,node=node,time=time,event=event,cascade=cascade,threshold=threshold)
diffusion_effects_variables <- data_for_dnehm[,(ncol(eha_data)+1):ncol(data_for_dnehm)]
diffusion_effects_variables <- (diffusion_effects_variables>0)*exp(-a*(diffusion_effects_variables))
covariate_variables <- cbind(eha_data[,covariates])
x_for_glmnet <- cbind(as.matrix(covariate_variables),as.matrix(diffusion_effects_variables))
colnames(x_for_glmnet) <- c(covariates,colnames(diffusion_effects_variables))
y_for_glmnet <- eha_data[,event]
boot.nonzero.est <- NULL
nboot <- 10
unique.cascades <- unique(eha_data[,cascade])
for(b in 1:nboot){
boot.samp <- sample(unique.cascades,length(unique.cascades),rep=T)
boot.data <- list()
for(i in 1:length(boot.samp)){
boot.data[[i]] <- eha_data[eha_data[,cascade]==boot.samp[i],]
}
boot.data <- data.frame(do.call('rbind',boot.data))
boot.dnehm_estimate <- dnehm(boot.data,node=node,time=time,event=event,covariates=covariates,cascade=cascade,threshold=threshold,a=a)
boot.dnehm.coef <- boot.dnehm_estimate$glmnet.fit$beta[,which(boot.dnehm_estimate$lambda==boot.dnehm_estimate$lambda.min)][which(boot.dnehm_estimate$glmnet.fit$beta[,which(boot.dnehm_estimate$lambda==boot.dnehm_estimate$lambda.min)] != 0)]
boot.recovered_edges <- substr(names(boot.dnehm.coef)[-c(1:(length(beta)-1))],2,nchar(names(boot.dnehm.coef)[-c(1:(length(beta)-1))]))
boot.nonzero.est <- c(boot.nonzero.est,boot.recovered_edges)
print(b)
}
freq.boot.est <- table(boot.nonzero.est)
bolasso.eff <- names(freq.boot.est)[which(freq.boot.est == nboot)]
bolasso.x <- cbind(covariate_variables,diffusion_effects_variables[,bolasso.eff])
colnames(bolasso.x) <- c(covariates,bolasso.eff)
bolasso.est <- glm(y_for_glmnet~bolasso.x,family="binomial")
bolasso.est
}
# basic data parameters
cascades <- 50
nodes <- 10
times <- 20
nties <- 10
# generate dataframe
time <- sort(rep(1:times,nodes))
node <- as.character(rep(1:nodes,times))
intercept <- rep(1,length(time))
covariate <- runif(length(time))-2
data_for_sim <- data.frame(time,node,intercept,covariate,stringsAsFactors=F)
# regression parameters
beta <- cbind(c(-2,.25))
rownames(beta) <- c("intercept","covariate")
## generate network effects
possible_ties <- rbind(t(combn(1:nodes,2)),t(combn(1:nodes,2))[,c(2,1)])
possible_ties <- paste(possible_ties[,1],possible_ties[,2],sep="_")
ties <- sample(possible_ties,nties)
gamma <- cbind(exp(rnorm(nties)/2))
rownames(gamma) <- ties
# initiate simulated data object
simulated_data <- NULL
# generate the data one cascade at a time (embarassingly parallel over c)
for(c in 1:cascades){
simulated_cascade <- simulate_dnehm_discrete(x=data_for_sim,node="node",time="time",beta=beta,gamma=gamma,a=0)
simulated_cascade <- data.frame(simulated_cascade,cascade=c,stringsAsFactors=F)
simulated_data <- rbind(simulated_data,simulated_cascade)
}
bolasso.results <- bolasso.dnehm(simulated_data,node="node",time="time",event="event",cascade="cascade",covariates="covariate",threshold=0,a=0)
bolasso.dnehm <- function(eha_data,node,time,event,cascade,covariates,threshold=0,a=0){
data_for_dnehm <- data_dnehm_discrete(eha_data,node=node,time=time,event=event,cascade=cascade,threshold=threshold)
diffusion_effects_variables <- data_for_dnehm[,(ncol(eha_data)+1):ncol(data_for_dnehm)]
diffusion_effects_variables <- (diffusion_effects_variables>0)*exp(-a*(diffusion_effects_variables))
covariate_variables <- cbind(eha_data[,covariates])
x_for_glmnet <- cbind(as.matrix(covariate_variables),as.matrix(diffusion_effects_variables))
colnames(x_for_glmnet) <- c(covariates,colnames(diffusion_effects_variables))
y_for_glmnet <- eha_data[,event]
boot.nonzero.est <- NULL
nboot <- 10
unique.cascades <- unique(eha_data[,cascade])
for(b in 1:nboot){
boot.samp <- sample(unique.cascades,length(unique.cascades),rep=T)
boot.data <- list()
for(i in 1:length(boot.samp)){
boot.data[[i]] <- eha_data[eha_data[,cascade]==boot.samp[i],]
}
boot.data <- data.frame(do.call('rbind',boot.data))
boot.dnehm_estimate <- dnehm(boot.data,node=node,time=time,event=event,covariates=covariates,cascade=cascade,threshold=threshold,a=a)
boot.dnehm.coef <- boot.dnehm_estimate$glmnet.fit$beta[,which(boot.dnehm_estimate$lambda==boot.dnehm_estimate$lambda.min)][which(boot.dnehm_estimate$glmnet.fit$beta[,which(boot.dnehm_estimate$lambda==boot.dnehm_estimate$lambda.min)] != 0)]
boot.recovered_edges <- substr(names(boot.dnehm.coef)[-c(1:(length(beta)-1))],2,nchar(names(boot.dnehm.coef)[-c(1:(length(beta)-1))]))
boot.nonzero.est <- c(boot.nonzero.est,boot.recovered_edges)
print(b)
}
freq.boot.est <- table(boot.nonzero.est)
bolasso.eff <- names(freq.boot.est)[which(freq.boot.est == nboot)]
print(colnames(diffusion_effects_variables))
print(bolasso.eff)
bolasso.x <- cbind(covariate_variables,diffusion_effects_variables[,bolasso.eff])
colnames(bolasso.x) <- c(covariates,bolasso.eff)
bolasso.est <- glm(y_for_glmnet~bolasso.x,family="binomial")
bolasso.est
}
# basic data parameters
cascades <- 50
nodes <- 10
times <- 20
nties <- 10
# generate dataframe
time <- sort(rep(1:times,nodes))
node <- as.character(rep(1:nodes,times))
intercept <- rep(1,length(time))
covariate <- runif(length(time))-2
data_for_sim <- data.frame(time,node,intercept,covariate,stringsAsFactors=F)
# regression parameters
beta <- cbind(c(-2,.25))
rownames(beta) <- c("intercept","covariate")
## generate network effects
possible_ties <- rbind(t(combn(1:nodes,2)),t(combn(1:nodes,2))[,c(2,1)])
possible_ties <- paste(possible_ties[,1],possible_ties[,2],sep="_")
ties <- sample(possible_ties,nties)
gamma <- cbind(exp(rnorm(nties)/2))
rownames(gamma) <- ties
# initiate simulated data object
simulated_data <- NULL
# generate the data one cascade at a time (embarassingly parallel over c)
for(c in 1:cascades){
simulated_cascade <- simulate_dnehm_discrete(x=data_for_sim,node="node",time="time",beta=beta,gamma=gamma,a=0)
simulated_cascade <- data.frame(simulated_cascade,cascade=c,stringsAsFactors=F)
simulated_data <- rbind(simulated_data,simulated_cascade)
}
bolasso.results <- bolasso.dnehm(simulated_data,node="node",time="time",event="event",cascade="cascade",covariates="covariate",threshold=0,a=0)
bolasso.dnehm <- function(eha_data,node,time,event,cascade,covariates,threshold=0,a=0){
data_for_dnehm <- data_dnehm_discrete(eha_data,node=node,time=time,event=event,cascade=cascade,threshold=threshold)
diffusion_effects_variables <- data_for_dnehm[,(ncol(eha_data)+1):ncol(data_for_dnehm)]
diffusion_effects_variables <- (diffusion_effects_variables>0)*exp(-a*(diffusion_effects_variables))
covariate_variables <- cbind(eha_data[,covariates])
x_for_glmnet <- cbind(as.matrix(covariate_variables),as.matrix(diffusion_effects_variables))
colnames(x_for_glmnet) <- c(covariates,colnames(diffusion_effects_variables))
y_for_glmnet <- eha_data[,event]
boot.nonzero.est <- NULL
nboot <- 10
unique.cascades <- unique(eha_data[,cascade])
for(b in 1:nboot){
boot.samp <- sample(unique.cascades,length(unique.cascades),rep=T)
boot.data <- list()
for(i in 1:length(boot.samp)){
boot.data[[i]] <- eha_data[eha_data[,cascade]==boot.samp[i],]
}
boot.data <- data.frame(do.call('rbind',boot.data))
boot.dnehm_estimate <- dnehm(boot.data,node=node,time=time,event=event,covariates=covariates,cascade=cascade,threshold=threshold,a=a)
boot.dnehm.coef <- boot.dnehm_estimate$glmnet.fit$beta[,which(boot.dnehm_estimate$lambda==boot.dnehm_estimate$lambda.min)][which(boot.dnehm_estimate$glmnet.fit$beta[,which(boot.dnehm_estimate$lambda==boot.dnehm_estimate$lambda.min)] != 0)]
boot.recovered_edges <- substr(names(boot.dnehm.coef)[-c(1:(length(beta)-1))],2,nchar(names(boot.dnehm.coef)[-c(1:(length(beta)-1))]))
boot.nonzero.est <- c(boot.nonzero.est,boot.recovered_edges)
print(b)
}
freq.boot.est <- table(boot.nonzero.est)
bolasso.eff <- names(freq.boot.est)[which(freq.boot.est == nboot)]
colnames(diffusion_effects_variables) <- substr(colnames(diffusion_effects_variables),2,nchar(colnames(diffusion_effects_variables)))
bolasso.x <- cbind(covariate_variables,diffusion_effects_variables[,bolasso.eff])
colnames(bolasso.x) <- c(covariates,bolasso.eff)
bolasso.est <- glm(y_for_glmnet~bolasso.x,family="binomial")
bolasso.est
}
# basic data parameters
cascades <- 50
nodes <- 10
times <- 20
nties <- 10
# generate dataframe
time <- sort(rep(1:times,nodes))
node <- as.character(rep(1:nodes,times))
intercept <- rep(1,length(time))
covariate <- runif(length(time))-2
data_for_sim <- data.frame(time,node,intercept,covariate,stringsAsFactors=F)
# regression parameters
beta <- cbind(c(-2,.25))
rownames(beta) <- c("intercept","covariate")
## generate network effects
possible_ties <- rbind(t(combn(1:nodes,2)),t(combn(1:nodes,2))[,c(2,1)])
possible_ties <- paste(possible_ties[,1],possible_ties[,2],sep="_")
ties <- sample(possible_ties,nties)
gamma <- cbind(exp(rnorm(nties)/2))
rownames(gamma) <- ties
# initiate simulated data object
simulated_data <- NULL
# generate the data one cascade at a time (embarassingly parallel over c)
for(c in 1:cascades){
simulated_cascade <- simulate_dnehm_discrete(x=data_for_sim,node="node",time="time",beta=beta,gamma=gamma,a=0)
simulated_cascade <- data.frame(simulated_cascade,cascade=c,stringsAsFactors=F)
simulated_data <- rbind(simulated_data,simulated_cascade)
}
bolasso.results <- bolasso.dnehm(simulated_data,node="node",time="time",event="event",cascade="cascade",covariates="covariate",threshold=0,a=0)
# Cascade-wise bootstrap to trim false positives (bolasso)
# https://www.di.ens.fr/willow/pdfs/icml_bolasso.pdf.
# the code below currently runs this as a cascade-wide bootstrap,
# but probably could do it with iid.
bolasso.dnehm <- function(eha_data,node,time,event,cascade,covariates,threshold=0,a=0){
data_for_dnehm <- data_dnehm_discrete(eha_data,node=node,time=time,event=event,cascade=cascade,threshold=threshold)
diffusion_effects_variables <- data_for_dnehm[,(ncol(eha_data)+1):ncol(data_for_dnehm)]
diffusion_effects_variables <- (diffusion_effects_variables>0)*exp(-a*(diffusion_effects_variables))
covariate_variables <- cbind(eha_data[,covariates])
x_for_glmnet <- cbind(as.matrix(covariate_variables),as.matrix(diffusion_effects_variables))
colnames(x_for_glmnet) <- c(covariates,colnames(diffusion_effects_variables))
y_for_glmnet <- eha_data[,event]
boot.nonzero.est <- NULL
nboot <- 10
unique.cascades <- unique(eha_data[,cascade])
for(b in 1:nboot){
boot.samp <- sample(unique.cascades,length(unique.cascades),rep=T)
boot.data <- list()
for(i in 1:length(boot.samp)){
boot.data[[i]] <- eha_data[eha_data[,cascade]==boot.samp[i],]
}
boot.data <- data.frame(do.call('rbind',boot.data))
boot.dnehm_estimate <- dnehm(boot.data,node=node,time=time,event=event,covariates=covariates,cascade=cascade,threshold=threshold,a=a)
boot.dnehm.coef <- boot.dnehm_estimate$glmnet.fit$beta[,which(boot.dnehm_estimate$lambda==boot.dnehm_estimate$lambda.min)][which(boot.dnehm_estimate$glmnet.fit$beta[,which(boot.dnehm_estimate$lambda==boot.dnehm_estimate$lambda.min)] != 0)]
boot.recovered_edges <- substr(names(boot.dnehm.coef)[-c(1:(length(beta)-1))],2,nchar(names(boot.dnehm.coef)[-c(1:(length(beta)-1))]))
boot.nonzero.est <- c(boot.nonzero.est,boot.recovered_edges)
print(b)
}
freq.boot.est <- table(boot.nonzero.est)
bolasso.eff <- names(freq.boot.est)[which(freq.boot.est == nboot)]
colnames(diffusion_effects_variables) <- substr(colnames(diffusion_effects_variables),2,nchar(colnames(diffusion_effects_variables)))
bolasso.x <- cbind(covariate_variables,diffusion_effects_variables[,bolasso.eff])
colnames(bolasso.x) <- c(covariates,bolasso.eff)
bolasso.est <- glm(y_for_glmnet~as.matrix(bolasso.x),family="binomial")
bolasso.est
}
# basic data parameters
cascades <- 50
nodes <- 10
times <- 20
nties <- 10
# generate dataframe
time <- sort(rep(1:times,nodes))
node <- as.character(rep(1:nodes,times))
intercept <- rep(1,length(time))
covariate <- runif(length(time))-2
data_for_sim <- data.frame(time,node,intercept,covariate,stringsAsFactors=F)
# regression parameters
beta <- cbind(c(-2,.25))
rownames(beta) <- c("intercept","covariate")
## generate network effects
possible_ties <- rbind(t(combn(1:nodes,2)),t(combn(1:nodes,2))[,c(2,1)])
possible_ties <- paste(possible_ties[,1],possible_ties[,2],sep="_")
ties <- sample(possible_ties,nties)
gamma <- cbind(exp(rnorm(nties)/2))
rownames(gamma) <- ties
# initiate simulated data object
simulated_data <- NULL
# generate the data one cascade at a time (embarassingly parallel over c)
for(c in 1:cascades){
simulated_cascade <- simulate_dnehm_discrete(x=data_for_sim,node="node",time="time",beta=beta,gamma=gamma,a=0)
simulated_cascade <- data.frame(simulated_cascade,cascade=c,stringsAsFactors=F)
simulated_data <- rbind(simulated_data,simulated_cascade)
}
bolasso.results <- bolasso.dnehm(simulated_data,node="node",time="time",event="event",cascade="cascade",covariates="covariate",threshold=0,a=0)
summary(bolasso.results)
# basic data parameters
cascades <- 50
nodes <- 10
times <- 20
nties <- 10
# generate dataframe
time <- sort(rep(1:times,nodes))
node <- as.character(rep(1:nodes,times))
intercept <- rep(1,length(time))
covariate <- runif(length(time))-2
data_for_sim <- data.frame(time,node,intercept,covariate,stringsAsFactors=F)
# regression parameters
beta <- cbind(c(-2,.25))
rownames(beta) <- c("intercept","covariate")
## generate network effects
possible_ties <- rbind(t(combn(1:nodes,2)),t(combn(1:nodes,2))[,c(2,1)])
possible_ties <- paste(possible_ties[,1],possible_ties[,2],sep="_")
ties <- sample(possible_ties,nties)
gamma <- cbind(exp(rnorm(nties)/2))
rownames(gamma) <- ties
# initiate simulated data object
simulated_data <- NULL
# generate the data one cascade at a time (embarassingly parallel over c)
for(c in 1:cascades){
simulated_cascade <- simulate_dnehm_discrete(x=data_for_sim,node="node",time="time",beta=beta,gamma=gamma,a=0)
simulated_cascade <- data.frame(simulated_cascade,cascade=c,stringsAsFactors=F)
simulated_data <- rbind(simulated_data,simulated_cascade)
}
bolasso.results <- bolasso.dnehm(simulated_data,node="node",time="time",event="event",cascade="cascade",covariates="covariate",threshold=0,a=0)
summary(bolasso.results)
gamma
# basic data parameters
cascades <- 50
nodes <- 10
times <- 20
nties <- 10
# generate dataframe
time <- sort(rep(1:times,nodes))
node <- as.character(rep(1:nodes,times))
intercept <- rep(1,length(time))
covariate <- runif(length(time))-2
data_for_sim <- data.frame(time,node,intercept,covariate,stringsAsFactors=F)
# regression parameters
beta <- cbind(c(-2,.25))
rownames(beta) <- c("intercept","covariate")
## generate network effects
possible_ties <- rbind(t(combn(1:nodes,2)),t(combn(1:nodes,2))[,c(2,1)])
possible_ties <- paste(possible_ties[,1],possible_ties[,2],sep="_")
ties <- sample(possible_ties,nties)
gamma <- cbind(exp(rnorm(nties)/2))
rownames(gamma) <- ties
# initiate simulated data object
simulated_data <- NULL
# generate the data one cascade at a time (embarassingly parallel over c)
for(c in 1:cascades){
simulated_cascade <- simulate_dnehm_discrete(x=data_for_sim,node="node",time="time",beta=beta,gamma=gamma,a=0)
simulated_cascade <- data.frame(simulated_cascade,cascade=c,stringsAsFactors=F)
simulated_data <- rbind(simulated_data,simulated_cascade)
}
bolasso.results <- bolasso.dnehm(simulated_data,node="node",time="time",event="event",cascade="cascade",covariates="covariate",threshold=0,a=0)
summary(bolasso.results)
gamma
# basic data parameters
cascades <- 50
nodes <- 50
times <- 20
nties <- 100
# generate dataframe
time <- sort(rep(1:times,nodes))
node <- as.character(rep(1:nodes,times))
intercept <- rep(1,length(time))
covariate <- runif(length(time))-2
data_for_sim <- data.frame(time,node,intercept,covariate,stringsAsFactors=F)
# regression parameters
beta <- cbind(c(-2,.25))
rownames(beta) <- c("intercept","covariate")
## generate network effects
possible_ties <- rbind(t(combn(1:nodes,2)),t(combn(1:nodes,2))[,c(2,1)])
possible_ties <- paste(possible_ties[,1],possible_ties[,2],sep="_")
ties <- sample(possible_ties,nties)
gamma <- cbind(exp(rnorm(nties)/2))
rownames(gamma) <- ties
# initiate simulated data object
simulated_data <- NULL
# generate the data one cascade at a time (embarassingly parallel over c)
for(c in 1:cascades){
simulated_cascade <- simulate_dnehm_discrete(x=data_for_sim,node="node",time="time",beta=beta,gamma=gamma,a=0)
simulated_cascade <- data.frame(simulated_cascade,cascade=c,stringsAsFactors=F)
simulated_data <- rbind(simulated_data,simulated_cascade)
}
bolasso.results <- bolasso.dnehm(simulated_data,node="node",time="time",event="event",cascade="cascade",covariates="covariate",threshold=0,a=0)
bolasso.coefs <- coef(bolasso.results)
bolasso.coefs <- names(coef(bolasso.results))
bolasso.coefs <- names(coef(bolasso.results))[-(1:length(beta))]
bolasso.coefs
bolasso.coefs <- names(coef(bolasso.results))[-(1:length(beta))]
bolasso.coefs <- substr(bolasso.coefs,25,nchar(bolasso.coefs))
bolasso.coefs
nchar("as.matrix(bolasso.x))
nchar("as.matrix(bolasso.x)")
bolasso.coefs <- substr(bolasso.coefs,21,nchar(bolasso.coefs))
bolasso.coefs
bolasso.coefs <- names(coef(bolasso.results))[-(1:length(beta))]
bolasso.coefs <- substr(bolasso.coefs,21,nchar(bolasso.coefs))
bolasso.coefs
recall <- mean(is.element(ties,bolasso.coefs))
recall
precision <- mean(is.element(bolasso.coefs,ties))
precision
rm(list=ls())
